%writeAlignedVol Write out the aligned sub-volumes as MRC files
%
%  writeAlignedVol(volume, modParticle, szVol, motiveList)
%
%   volume      The MRCImage volume containing the sub volumes.
%
%   modParticle The ImodObject contain the particle points.
%
%   szVol       The size of the sub-volume.
%
%   motiveList  The motivelist containing the rotations, shifts and CCC
%               values.

function writeAlignedVol(volume, modParticle, szVol, motiveList, fnParticle, ...
  threshold, tiltRange, edgeShift, excludeList, meanFill, debugLevel)

global PRINT_ID
if PRINT_ID
    fprintf('$Id: writeAlignedVol.m,v 1.6 2005/08/15 23:17:37 rickg Exp $\n');
end

if nargin < 5
  threshold = 0;
end

if nargin < 7
  edgeShift = 0;
end

if nargin > 5
  wMask = wedgeMask(tiltRange, szVol, 'Y', edgeShift);
  maskSum = zeros(size(wMask));
end

if nargin < 8
  excludeList = [];
end

if nargin < 9
  meanFill = 0;
end

if nargin < 10
  alignedBaseName = '';
end

if nargin < 11
  debugLevel = 0;
end

% If the threshold is > 1 sort the cross correlation coefficient to find
% the appropriate threshold
if threshold >= 1
  CCCsort = sort(motiveList(1,:), 2, 'descend');
  threshold = CCCsort(threshold) - eps;
  if debugLevel > 1
    fprintf('Using similarity threshold of: %f\n', threshold);
  end
end


% Get the particle centers from the model
ptsParticles = imodPoints2Index(getPoints(modParticle, 1, 1));
nParticles = size(motiveList, 2);

% Select an index at center of the volume or near it (even case) to
% represent the origin for rotation
idxOrigin = floor(szVol / 2) + 1;

for idxParticle = 1:nParticles
  idParticle = motiveList(4, idxParticle);
  
  center = ptsParticles(:, idParticle);
  particle = single(extractSubVolume(volume, center, szVol));
  
  fprintf('Particle %d ID %d included CCC=%6.4f  ', idxParticle, ...
    motiveList(4, idxParticle), motiveList(1, idxParticle));
  fprintf('phi %6.4f  theta %6.4f  psi %6.4f  ', ...
    motiveList([17 19 18], idxParticle)');
  fprintf('dx %6.4f  dy %6.4f dz %6.4f\n', ...
    motiveList(11:13, idxParticle)');

  % Recall that the MOTL has the Euler angles in a strange order
  % Shift then rotate the particle.  The inverse transform used to create the
  % motive list is applied because the motive list was generated by
  % transforming the reference to the particle
  particle = ...
    volumeShiftRotateInv(particle, -motiveList([11 12 13], idxParticle)', ...
    motiveList([17 19 18], idxParticle)' * -pi / 180, idxOrigin);

  mrcVol = MRCImage(particle);
  strIndex = sprintf('%03d', idParticle);
  save(mrcVol, [fnParticle strIndex '.mrc']);
  
  
end